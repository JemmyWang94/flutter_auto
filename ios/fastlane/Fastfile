# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#  fastlane dev_build_upload content:"æ›´æ–°å¤‡æ³¨" desc:"è’²å…¬è‹±çš„æ›´æ–°å¤‡æ³¨"

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

###################################

# å‘½ä»¤è¡Œè°ƒç”¨ lane : fastlane example_lane key1:value1 key2:value2
# é€šè¿‡ import "è·¯å¾„/other_fastfile" å¯¼å…¥æœ¬åœ°å…¶ä»–fastfileæ–‡ä»¶, å¯è°ƒç”¨å…¶ä¸­çš„ lane
# ä½†éœ€è¦æ³¨æ„çš„æ˜¯ å¦‚æžœä¸¤ä¸ª fastfile éƒ½å¼•å…¥äº†åŒä¸€ä¸ª fastfile æ–‡ä»¶, ä¼šå‡ºçŽ°é‡å¤å®šä¹‰çš„è­¦å‘Š

# ä¸€äº›è°ƒç”¨ lane éœ€è¦ç”¨åˆ°çš„å‚æ•°çš„æ­£ç¡®å†™æ³•:
# é¡¹ç›®æž„å»ºçŽ¯å¢ƒ config : Debug Test Release Ad_hoc
# å¯¼å‡ºåŒ…çš„æ–¹å¼ method : app-store, validation, ad-hoc, package, enterprise, development, developer-id, mac-application

# ruby ç¼–ç è§„èŒƒ: http://stylesror.github.io/

# å…¨å±€å‚æ•°
SCHEME_NAME  = "Runner"
IPA_NAME     = "Runner"  # åŒ…å
IPA_ROOT_DIR = ENV['TCOUTPUT_DIR'] # æž„å»ºçš„ipaè¾“å‡ºè·¯å¾„

WECOM_IOS_GROUP = "https://fortexinc.webhook.office.com/webhookb2/437b0063-763d-49fb-be6f-832d792b2d88@107f5168-dae8-4735-8b95-b5f7f81a1df6/IncomingWebhook/739bd2037617492fa386ad031dc918e6/ebf5569a-e8b5-4e2f-9f07-13294db238a2/V2RG2j9Lp39h4CJOqptrpjb47ntANIz7HPLRJXoOOFlx81"


default_platform(:ios)

platform :ios do

  lane :dev_clean_workspace do |options|
    fx_git_clean_workspace()
  end

  lane :send_msg do |options|
    content = options[:content]
    desc    = options[:desc]

    send_wecom_msg(content: content,
                       webhook: WECOM_IOS_GROUP,
                       call_all: true)
  end
  
  # ä¸€é”®æ‰“åŒ…ä¸Šä¼ devçŽ¯å¢ƒçš„ipa æ²¡æœ‰æ¸…ç©ºå’Œæ›´æ–°podæ“ä½œ
  # - content æ¶ˆæ¯ç¾¤çš„æ›´æ–°å†…å®¹
  # - desc è’²å…¬è‹±çš„æ›´æ–°ä¿¡æ¯
  lane :dev_build_upload_withoutpod do |options|
    content = options[:content]
    desc    = options[:desc]

    fx_set_build_settings(project_name: SCHEME_NAME,
                           settings_key: "FLUTTER_BUILD_MODE",
                           settings_value: "release",
                           config: "Debug")

    ipa_file = build_dev()

    result = upload_pgy(ipa_file: ipa_file, msg: content)

    buildVersion      = result[:buildVersion]
    buildBuildVersion = result[:buildBuildVersion]
    buildQRCodeURL    = result[:buildQRCodeURL]
    buildShortcutUrl  = result[:buildShortcutUrl]

    msg = "#{content}\nQR code link: #{buildQRCodeURL}"

    data = last_git_commit_info()

    msg = "****** #{SCHEME_NAME} dev Packaging success ******\n
    \nBuild result: Success\n
    \nBuild branch: #{data[:branch]}\n
    \nRecord SHA: #{data[:sha]}\n
    \nSubmit Author: #{data[:author]}\n
    \nDownload Link: #{buildShortcutUrl}\n
    \nRecord Updates: #{data[:remark]}\n
    \nUpdate Notes: #{content}\n
    \nQR code link: #{buildQRCodeURL}\n"

    send_success_wecom(content: msg,
                       webhook: WECOM_IOS_GROUP,
                       call_all: true)
  end

  # ä¸€é”®æ‰“åŒ…ä¸Šä¼ devçŽ¯å¢ƒçš„ipa
  # - content æ¶ˆæ¯ç¾¤çš„æ›´æ–°å†…å®¹
  # - desc è’²å…¬è‹±çš„æ›´æ–°ä¿¡æ¯
  lane :dev_build_upload do |options|

    content = options[:content]
    desc    = options[:desc]

    fx_git_clean_workspace()

    pod_update()

    fx_set_build_settings(project_name: SCHEME_NAME,
                           settings_key: "FLUTTER_BUILD_MODE",
                           settings_value: "release",
                           config: "Debug")

    ipa_file = build_dev()

    result = upload_pgy(ipa_file: ipa_file, msg: content)

    buildVersion      = result[:buildVersion]
    buildBuildVersion = result[:buildBuildVersion]
    buildQRCodeURL    = result[:buildQRCodeURL]
    buildShortcutUrl  = result[:buildShortcutUrl]

    msg = "#{content}\nQR code link: #{buildQRCodeURL}"

    data = last_git_commit_info()

    msg = "****** #{SCHEME_NAME} dev packaging success ******
    Build result: Success
    Build branch: #{data[:branch]}
    Record SHA: #{data[:sha]}
    Submit Author: #{data[:author]}
    Download Link: #{buildShortcutUrl}
    Record Updates: #{data[:remark]}
    Update Notes: #{content}
    QR code link: #{buildQRCodeURL}"

    send_success_wecom(content: msg,
                       webhook: WECOM_IOS_GROUP,
                       call_all: true)
                       
    fx_git_clean_workspace()

  end
  
  ############## pod, git ç›¸å…³æ“ä½œ ##############
  
  # æ›´æ–° pod
  lane :pod_update do |options|
    UI.message("pod_update current dir: #{Dir.pwd}")
    Dir.chdir("..") do
      UI.message("pod_update change dir: #{Dir.pwd}")
      system("pod install")
    end
    UI.message("Restore path after pod_update execution: #{Dir.pwd}")
  end
  
  # åˆ‡æ¢æœ¬åœ°åˆ†æ”¯ ä¸ä¼ å€¼, é»˜è®¤åˆ‡æ¢ä¸ºä¸»åˆ†æ”¯
  # - branch: åˆ†æ”¯åç§°
  lane :git_checkout_branch do |options|
    branch = options[:branch]
    if branch.nil? || branch.empty?
      branch = 'master'
    end
    exec("git checkout #{branch}")
  end
  
  # è°ƒç”¨è„šæœ¬æ¸…ç©ºæœ¬åœ°å·¥ä½œåŒºå’Œç¼“å­˜åŒº
  lane :git_clean_workspace do |options|
    Dir.chdir("../")
    exec("sh git_clean_workspace.sh")
  end
  
  # èŽ·å–å½“å‰åˆ†æ”¯æœ€æ–°ä¸€æ¬¡æäº¤è®°å½•ä¿¡æ¯
  lane :last_git_commit_info do |options|
    # èŽ·å–gitåˆ†æ”¯æœ€åŽä¸€æ¬¡æäº¤è®°å½•ä¿¡æ¯ %h ç²¾ç®€shaå€¼, %an ä½œè€…å, %ad ä½œè€…ä¿®è®¢æ—¶é—´, %cn æäº¤è€…å, %cd æäº¤æ—¥æœŸ, %s æäº¤è¯´æ˜Ž
    puts `git log --pretty=format:"sha:%h\nauthor:%an\nauthor_mail:%ae\nauthor_date:%ad\ncommitter:%cn\ncommitter_mail:%ce\ncommit_date:%cd\nremark:%s" -1>git_log_msg.txt`

    puts `git rev-parse --abbrev-ref HEAD>git_branch_msg.txt`

    git_branch_name = File.read("git_branch_msg.txt").sub("\n", "")

    # èŽ·å–git log è¾“å‡ºå†…å®¹, å¹¶åˆ é™¤è¾“å‡ºçš„txt
    sha         = ""
    author      = ""
    author_mail = ""
    committer   = ""
    commit_mail = ""
    commit_date = ""
    remark      = ""

    git_log_file = File.open('git_log_msg.txt')
    git_log_file.each_line {|line|

      if line.include? "sha:"
        puts "Sha: #{line.sub("sha:", "")}"
        sha = line.sub("sha:", "").sub("\n", "")
      elsif line.include? "author:"
        puts "Author: #{line.sub("author:", "")}"
        author = line.sub("author:", "").sub("\n", "")
      elsif line.include? "author_mail:"
        puts "Email: #{line.sub("author_mail:", "")}"
        author_mail = line.sub("author_mail:", "").sub("\n", "")
      elsif line.include? "author_date:"
        puts "Revision Time: #{line.sub("author_date:", "")}"
      elsif line.include? "committer:"
        puts "Submitted by: #{line.sub("committer:", "")}"
        committer = line.sub("committer:", "").sub("\n", "")
      elsif line.include? "committer_mail:"
        puts "Submitted Email: #{line.sub("committer_mail:", "")}"
        commit_mail = line.sub("committer_mail:", "").sub("\n", "")
      elsif line.include? "committer_date:"
        puts "Submitted Time: #{line.sub("commit_date:", "")}"
        commit_date = line.sub("commit_date:", "").sub("\n", "")
      elsif line.include? "remark:"
        puts "Remark: #{line.sub("remark:", "")}"
        remark = line.sub("remark:", "").sub("\n", "")
      else
        puts "Other: #{line}"
      end
    }
    File::delete("#{Dir::pwd}/git_log_msg.txt")
    File::delete("#{Dir::pwd}/git_branch_msg.txt")

    {"branch": git_branch_name, "sha": sha, "author": author, "author_mail": author_mail, "committer": committer, "commit_mail": commit_mail, "commit_date": commit_date, "remark": remark}

  end
  
  ############## æž„å»º, æ‰“åŒ… (æš‚æ—¶ä»…æ”¯æŒdevæ‰“åŒ…) ##############

  # å¼€å‘çŽ¯å¢ƒæž„å»ºæ‰“åŒ…ä¸Šä¼ åˆ°è’²å…¬è‹±
  # - desc: stirng è’²å…¬è‹±Update Notes
  # - content: string æ¶ˆæ¯å†…å®¹
  lane :dev_build_pgy do |options|
    ipa_file = build_dev()

    content = options[:content]
    desc    = options[:desc]

    result = upload_pgy(ipa_file: ipa_file, msg: desc)

    buildVersion      = result[:buildVersion]
    buildBuildVersion = result[:buildBuildVersion]
    buildQRCodeURL    = result[:buildQRCodeURL]
    buildShortcutUrl  = result[:buildShortcutUrl]

    msg = "#{content}\nQR code link: #{buildQRCodeURL}"
    
    send_success_wecom(content: msg,
                       webhook: WECOM_IOS_GROUP,
                       call_all: true)
  end
  
  # æž„å»ºå¼€å‘çŽ¯å¢ƒçš„ipa
  lane :build_dev do
    ipa_path = "#{IPA_ROOT_DIR}/development"
    ipa_file = ipa_build(scheme: SCHEME_NAME,
             config: "Debug",
             ipa_name: IPA_NAME,
             bitcode: false,
             path: ipa_path)
    ipa_file
  end
  
  # æž„å»ºæ‰“åŒ…
  # - scheme: sring æž„å»ºé€‰æ‹©çš„ scheme
  # - config: sring æž„å»ºçŽ¯å¢ƒ å›ºå®šä¸º Debug Test Ad_hoc Release
  # - ipa_name: string ipaåŒ…å
  # - bitcode: Boolean æ˜¯å¦å¯ç”¨ bitcode
  # - path: string ipaåŒ…å­˜æ”¾è·¯å¾„
  lane :ipa_build do |options|
    config   = options[:config]
    ipa_name = options[:ipa_name]
    method   = ""

    # é…ç½®ä¸åŒé¡¹ç›®çŽ¯å¢ƒçš„åŒ…åå’Œæž„å»ºæ–¹å¼
    if config.eql?("Debug")
      method   = "development"
      ipa_name = "#{options[:ipa_name]}_dev.ipa"
    elsif config.eql?("Test")
      method   = "development"
      ipa_name = "#{options[:ipa_name]}_test.ipa"
    elsif config.eql?("Ad_hoc")
      method   = "ad-hoc"
      ipa_name = "#{options[:ipa_name]}_adhoc.ipa"
    elsif config.eql?("Release")
      method   = "app-store"
      ipa_name = "#{options[:ipa_name]}_release.ipa"
    else
      UI.user_error!("The selected build environment is not currently supported. Currently only supports: Debug Test Ad_hoc Release and above environment builds!")
    end

    bitcode  = options[:bitcode]
    ipa_path = options[:path]

    ipa_file = "#{ipa_path}/#{ipa_name}"

    UI.message("ðŸ‘¨â€ðŸ³ Start building and packaging...")
    gym(workspace: ENV['TCWORKSPACE'],
        scheme: options[:scheme],
        configuration: config,
        export_method: method,
        output_directory: ipa_path,
        output_name: ipa_name,
        include_symbols: true,
        include_bitcode: bitcode,
        clean: true)

    ipa_file
  end
  
  ############## ä¸Šä¼ åˆ°ç¬¬ä¸‰æ–¹åˆ†å‘å¹³å° ##############

  # ä¸Šä¼ åˆ°è’²å…¬è‹±
  # - ipa_file: string ipaæ–‡ä»¶è·¯å¾„
  # - msg: string å‘ç‰ˆå†…å®¹
  lane :upload_pgy do |options|
    UI.message("------ upload pgy start ------")
    upload_msg = options[:msg]
    ipa_file   = options[:ipa_file]
    # æ’ä»¶ä¸Šä¼ ä¸èƒ½èŽ·å–äºŒç»´ç åœ°å€
    # pgyer(api_key: ENV['PGY_API_KEY'],
    #       user_key: ENV['PGY_USER_KEY'],
    #       update_description: upload_msg)
    data = fx_upload_pgy(api_key: ENV['PGY_API_KEY'], file: ipa_file, desc: upload_msg)

    UI.success("------ upload pgy success ------")
    data
  end
  
  ############## å‘é€æ¶ˆæ¯ lane ##############

  # å‘é€æ¶ˆæ¯
  # - content: string æ¶ˆæ¯å†…å®¹
  # - webhook: string ç¾¤æ¶ˆæ¯æœºå™¨äººçš„é“¾æŽ¥
  # - call_list: array(string) éœ€è¦@çš„äººæ‰‹æœºå·æ•°ç»„
  lane :send_wecom_msg do |options|
    UI.success "ðŸ¤ŸðŸ¤ŸðŸ¤Ÿ Send message:"
    content   = options[:content]
    UI.success "ðŸ¤ŸðŸ¤ŸðŸ¤Ÿ content ----- #{content}"
    webhook   = options[:webhook]
    call_list = options[:call_list]

    url  = webhook
    fx_teams(msgtype: "text",
              content: content.force_encoding('UTF-8'),
              webhook: url)
  end

  # å‘é€æ‰§è¡ŒæˆåŠŸçš„æ¶ˆæ¯
  #  content: string æ¶ˆæ¯å†…å®¹
  #  webhook: string ç¾¤æ¶ˆæ¯æœºå™¨äººçš„é“¾æŽ¥
  #  call_all: boolean æ˜¯å¦@æ‰€æœ‰äºº
  lane :send_success_wecom do |options|
    UI.success "ðŸ¤ŸðŸ¤ŸðŸ¤Ÿ Lane is successfully executed and a message will be sent"
    content  = options[:content]
    webhook  = options[:webhook]
    call_all = options[:call_all]

    text = "--------- lane execute done ---------\n#{content.force_encoding('UTF-8')}"
    url  = webhook
    fx_teams(msgtype: "text",
              content: text,
              webhook: url)
  end
  
  ############## å¤„ç† lane æ‰§è¡Œçš„ lane ##############

  # æ¯ä¸ª lane è°ƒç”¨å‰ä¼šæ‰§è¡Œ, ä½†å†…éƒ¨è°ƒç”¨çš„ lane ä¸ä¼šè§¦å‘
  # - lane ä¼ å…¥çš„laneå
  # - options å¸¦çš„å‚æ•°
  before_all do |lane, options|
    UI.message("ðŸ‘¨â€ðŸ³ Will execute lane: #{lane}")
    UI.message("ðŸ‘¨â€ðŸ³ #{lane} params is #{options}")

    ENV["MATCH_PASSWORD"] = "123"
    # é…ç½®è¶…æ—¶æ—¶é—´å’Œé‡è¯•æ¬¡æ•°
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "5"
  end

  # lane æ‰§è¡ŒæˆåŠŸä¹‹åŽä¼šæ‰§è¡Œ, ä½†å†…éƒ¨è°ƒç”¨ lane ä¸ä¼šè§¦å‘
  # - lane ä¸ºè°ƒç”¨çš„laneå
  # - options å¸¦çš„å‚æ•°
  after_all do |lane, options|

    # TODO: å¯ä»¥ç”¨å­—ç¬¦ä¸²çš„æ–¹å¼æ¥åˆ¤æ–­æ˜¯å¦ä¸ºç‰¹å®šçš„ lane
    # if "#{lane}".eql?("æŒ‡å®šçš„laneå")
    # else
    # end

    UI.success("ðŸ¤Ÿ lane: #{lane} execute success")
  end

  # lane æ‰§è¡Œå¤±è´¥ä¼šè¿›å…¥åˆ° error lane, è¿™é‡Œæš‚æ—¶åªå‘é€å¤±è´¥æ¶ˆæ¯åˆ°æ¶ˆæ¯ç¾¤
  error do |lane, options|
    UI.error("âŒâŒâŒ Lane execution error, error information will be sent to the message group!!!")
    UI.error("ðŸ‘‰ðŸ‘‰ðŸ‘‰ The failed lane: #{lane}")
    UI.error("ðŸ‘®ðŸ‘®ðŸ‘® Reason for the error: #{options}")
    text = "--------- Lane execution failed ---------\n --->>> Failed lane: #{lane}\n --->>> Error details: #{options}"
    fx_teams(msgtype: "text",
              content: text,
              webhook: WECOM_IOS_GROUP)
  end
  
end
